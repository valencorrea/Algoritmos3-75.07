
<!-- saved from url=(0057)https://www.smalltalking.net/Papers/stDesign/stDesign.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><link rel="stylesheet" href="./Smalltalking_ Design Principles Behind Smalltalk_files/frontpage.css" type="text/css">

<title>Smalltalking: Design Principles Behind Smalltalk</title>
</head>
<body link="#0000ff" vlink="#800080" background="./Smalltalking_ Design Principles Behind Smalltalk_files/background.gif" bgcolor="#ffffff">

<h1><gistnote class="gistnote-highlight" highlightid="15a73a51-77a0-4991-b48b-bc4c3f3de694" colornum="3" style="background-color: rgb(255, 251, 120);" id="15a73a51-77a0-4991-b48b-bc4c3f3de694">Principios de Diseño de Smalltalk</gistnote>
<br>Design Principles Behind Smalltalk</h1>

<h3>por <gistnote class="gistnote-highlight" highlightid="d44024bf-d764-4532-ad6c-a2e09920b565" colornum="3" style="background-color: rgb(255, 251, 120);" id="d44024bf-d764-4532-ad6c-a2e09920b565">Daniel H H Ingalls</gistnote></h3>
publicado originalmente en Byte, Agosto de 1981, dedicada a Smalltalk

<p>El propósito del proyecto Smalltalk es proveer soporte de computación al espíritu creativo que todos llevamos dentro. Nuestro trabajo se desarrolla a partir de una visión que incluye a un individuo creativo y al mejor hardware de computación disponible. Elegimos concentrarnos en dos áreas principales de investigación: un <gistnote class="gistnote-highlight" highlightid="294b5780-a2c7-434f-bd5e-b27f59661eab" colornum="5" style="background-color: rgb(180, 255, 235);" id="294b5780-a2c7-434f-bd5e-b27f59661eab">lenguaje de descripción (lenguaje de programación)</gistnote> que sirve de <gistnote class="gistnote-highlight" highlightid="2522dd6f-3bd7-44de-afff-e005afc95c9a" colornum="5" style="background-color: rgb(180, 255, 235);" id="2522dd6f-3bd7-44de-afff-e005afc95c9a">interfaz entre los modelos en la mente humana y aquellos en el hardware</gistnote>, y un lenguaje de <gistnote class="gistnote-highlight" highlightid="5cf06634-20fb-4cf8-9004-434640e01c76" colornum="5" style="background-color: rgb(180, 255, 235);" id="5cf06634-20fb-4cf8-9004-434640e01c76">interacción (interfaz al usuario)</gistnote> que adapte el sistema de <gistnote class="gistnote-highlight" highlightid="d22b99d9-d28a-469d-8706-5346910d19b9" colornum="5" style="background-color: rgb(180, 255, 235);" id="d22b99d9-d28a-469d-8706-5346910d19b9">comunicación humano a la computadora</gistnote>. Nuestro trabajo ha seguido un ciclo de dos a cuatro años que se puede ver como paralelo al método científico:
</p><p>· Construir un programa de aplicación dentro del sistema actual (hacer una <gistnote class="gistnote-highlight" highlightid="331fbb31-1847-464f-9c6c-b2c0b1e23dfd" colornum="4" style="background-color: rgb(209, 255, 97);" id="331fbb31-1847-464f-9c6c-b2c0b1e23dfd">observación</gistnote>)
</p><p>· Basado en esta experiencia, rediseñar el lenguaje (construir una <gistnote class="gistnote-highlight" highlightid="8dcf56f7-1c74-4fe4-acf1-51b8680d1292" colornum="4" style="background-color: rgb(209, 255, 97);" id="8dcf56f7-1c74-4fe4-acf1-51b8680d1292">teoría</gistnote>)
</p><p>· Construir un nuevo sistema basado en el nuevo diseño (hacer una <gistnote class="gistnote-highlight" highlightid="9e575b3b-2a56-4d74-aa64-ca6bcc379dc8" colornum="4" style="background-color: rgb(209, 255, 97);" id="9e575b3b-2a56-4d74-aa64-ca6bcc379dc8">predicción</gistnote> que puede ser corroborada)
</p><p>
</p><p>El sistema Smalltalk-80 marca nuestra quinta iteración sobre este ciclo. En este artículo, presento algunos de los principios generales que hemos observado en el curso de nuestro trabajo. Si bien la presentación se basa frecuentemente en Smalltalk, los principios son más generales y deberían ser útiles para evaluar otros sistemas y guiar trabajo futuro.
</p><p>Para ir empezando, un <gistnote class="gistnote-highlight" highlightid="ebd63efb-2dfe-40fd-9293-f5572ae89351" colornum="2" style="background-color: rgb(255, 222, 112);" id="ebd63efb-2dfe-40fd-9293-f5572ae89351">principio</gistnote> que es más social que técnico y que es largamente responsable de la particular orientación del proyecto Smalltalk:
</p><p>
</p><p><b><gistnote class="gistnote-highlight" highlightid="3dbfe5b4-437e-42ee-ba11-ac036ad2dd3f" colornum="2" style="background-color: rgb(255, 222, 112);" id="3dbfe5b4-437e-42ee-ba11-ac036ad2dd3f">Dominio Personal:</gistnote> </b> <i>Si un sistema es <gistnote class="gistnote-highlight" highlightid="6e8d6755-c850-453c-9d85-329126f29de1" colornum="2" style="background-color: rgb(255, 222, 112);" id="6e8d6755-c850-453c-9d85-329126f29de1">para servir al espíritu creativo</gistnote>, debe ser completamente <gistnote class="gistnote-highlight" highlightid="da430eb8-cac0-463b-8899-e325f358eda1" colornum="2" style="background-color: rgb(255, 222, 112);" id="da430eb8-cac0-463b-8899-e325f358eda1">entendible</gistnote> para un <gistnote class="gistnote-highlight" highlightid="3d7b617d-5150-455e-a1a6-7c7b075524cb" colornum="2" style="background-color: rgb(255, 222, 112);" id="3d7b617d-5150-455e-a1a6-7c7b075524cb">individuo solitario</gistnote>.</i>
</p><p>
</p><p>El punto aquí es que el potencial humano se manifiesta en los individuos. Para efectivizar este potencial, debemos proveer un <gistnote class="gistnote-highlight" highlightid="e2ced91f-5b69-4f59-b883-4c7dc7c756a4" colornum="2" style="background-color: rgb(255, 222, 112);" id="e2ced91f-5b69-4f59-b883-4c7dc7c756a4">medio</gistnote> que pueda ser <gistnote class="gistnote-highlight" highlightid="404e2734-8fb2-4ca0-b47f-0192c5f08d73" colornum="2" style="background-color: rgb(255, 222, 112);" id="404e2734-8fb2-4ca0-b47f-0192c5f08d73">dominado completamente por un individuo</gistnote>. <gistnote class="gistnote-highlight" highlightid="99e46cb8-ce97-40ab-91b4-46dc461d3f9a" colornum="2" style="background-color: rgb(255, 222, 112);" id="99e46cb8-ce97-40ab-91b4-46dc461d3f9a">Cualquier barrera</gistnote> que exista entre el usuario y alguna parte del sistema será finalmente una <gistnote class="gistnote-highlight" highlightid="0ca0c879-458b-4aac-8992-677f3a912cee" colornum="2" style="background-color: rgb(255, 222, 112);" id="0ca0c879-458b-4aac-8992-677f3a912cee">barrera a la expresión creativa.</gistnote> Cualquier <gistnote class="gistnote-highlight" highlightid="223d66f1-13b6-433b-8040-1e23fb4b1eef" colornum="2" style="background-color: rgb(255, 222, 112);" id="223d66f1-13b6-433b-8040-1e23fb4b1eef">parte del sistema que no pueda ser cambiada</gistnote>, o que no es lo suficientemente general es probablemente un origen de <gistnote class="gistnote-highlight" highlightid="feeeea8b-656e-4ce5-a8c1-8abc16380ac3" colornum="2" style="background-color: rgb(255, 222, 112);" id="feeeea8b-656e-4ce5-a8c1-8abc16380ac3">impedimentos</gistnote>. Si una parte del sistema funciona de manera diferente del resto, esa parte requiere un <gistnote class="gistnote-highlight" highlightid="ff868237-bb37-4fbc-bd35-b780a20a4587" colornum="2" style="background-color: rgb(255, 222, 112);" id="ff868237-bb37-4fbc-bd35-b780a20a4587">esfuerzo adicional</gistnote> para controlarla. Esa complicación añadida puede afectar el resultado final, e inhibir futuros esfuerzos en esa área. Podemos entonces inferir un <gistnote class="gistnote-highlight" highlightid="09bd543f-f31d-4734-9575-63a364882529" colornum="2" style="background-color: rgb(255, 222, 112);" id="09bd543f-f31d-4734-9575-63a364882529">principio general de diseño</gistnote>:
</p><p>
</p><p><b><gistnote class="gistnote-highlight" highlightid="643bae1a-3b2d-4cc8-af7e-9b2bfd36b4dc" colornum="2" style="background-color: rgb(255, 222, 112);" id="643bae1a-3b2d-4cc8-af7e-9b2bfd36b4dc">Buen Diseño</gistnote>:</b> <i>Un sistema debería ser construido con un <gistnote class="gistnote-highlight" highlightid="5164181e-18f3-4696-9858-2863b3d83512" colornum="2" style="background-color: rgb(255, 222, 112);" id="5164181e-18f3-4696-9858-2863b3d83512">mínimo conjunto de partes no modificables</gistnote>; esas partes debieran ser tan <gistnote class="gistnote-highlight" highlightid="b736f99a-f343-4ebb-830b-978c4379e532" colornum="2" style="background-color: rgb(255, 222, 112);" id="b736f99a-f343-4ebb-830b-978c4379e532">generales</gistnote> como sea posible; y todas las partes del sistema deberían estar <gistnote class="gistnote-highlight" highlightid="b8c362db-2c6b-49ea-b74e-ce121d290ff7" colornum="2" style="background-color: rgb(255, 222, 112);" id="b8c362db-2c6b-49ea-b74e-ce121d290ff7">mantenidas en un esquema uniforme.</gistnote></i>
</p><p>
</p><h3>Lenguaje.</h3>
<p>Al diseñar un lenguaje para ser usado con computadoras, no es necesario mirar muy lejos para buscar indicaciones útiles. Todo lo que sabemos sobre cómo la gente piensa y se comunica es aplicable. Los mecanismos del pensamiento y la comunicación humanos han sido pulidos durante millones de años, y deberíamos considerarlos bien diseñados. Más aún, como deberemos trabajar con este diseño durante el próximo millón de años, nos ahorrará tiempo si hacemos que nuestros <gistnote class="gistnote-highlight" highlightid="e20d16b8-c9cb-4cfd-bff2-9966609475c0" colornum="1" style="background-color: rgb(255, 202, 215);" id="e20d16b8-c9cb-4cfd-bff2-9966609475c0">modelos de computación sean compatibles con la mente</gistnote>, en vez de hacerlo al revés.
</p><p>
</p><center><font size="-1">
<img src="./Smalltalking_ Design Principles Behind Smalltalk_files/fig1.gif"><br>Figura 1: El alcance del diseño de un lenguaje.
</font><p><font size="-1">La comunicación entre dos personas (o entre una persona y una computadora) incluye comunicación en dos niveles. La comunicación explícita incluye la información que es transmitida en determinado mensaje. La comunicación implícita incluye las suposiciones relevantes comunes a los dos seres.
</font></p></center><p>
</p><p>La figura 1 ilustra los principales componentes en nuestra discusión. Una persona es presentada como teniendo un cuerpo y una mente. El cuerpo es el lugar de la experiencia primaria, y en el contexto de esta discusión, es el canal físico a través del cual el universo es percibido y a través del cual las intenciones son realizadas. La experiencia es recordada y procesada en la mente. <gistnote class="gistnote-highlight" highlightid="66de885b-990c-404b-8d22-229d8b7c03bf" colornum="1" style="background-color: rgb(255, 202, 215);" id="66de885b-990c-404b-8d22-229d8b7c03bf">El pensamiento creativo</gistnote> (sin internarnos en su funcionamiento) puede ser visto como la <gistnote class="gistnote-highlight" highlightid="73036cf1-8e5f-4485-8055-3421eecff7c7" colornum="1" style="background-color: rgb(255, 202, 215);" id="73036cf1-8e5f-4485-8055-3421eecff7c7">aparición espontánea de información en la mente</gistnote>. El lenguaje es la clave a esta información:
</p><p>
</p><p><b><gistnote class="gistnote-highlight" highlightid="07a13720-f48a-4509-b072-9f6fb747e6c1" colornum="1" style="background-color: rgb(255, 202, 215);" id="07a13720-f48a-4509-b072-9f6fb747e6c1">Propósito del lenguaje</gistnote>:</b> <i><gistnote class="gistnote-highlight" highlightid="cccbeaf3-4dd5-459d-b909-f624f9f6a1d2" colornum="1" style="background-color: rgb(255, 202, 215);" id="cccbeaf3-4dd5-459d-b909-f624f9f6a1d2">Proveer un esquema para la comunicación</gistnote>.</i>
</p><p>
</p><p>La interacción entre dos individuos es representada en la figura 1 como dos arcos. El arco sólido representa la comunicación <gistnote class="gistnote-highlight" highlightid="2ee58e51-4293-44e9-bb76-ce4342550637" colornum="1" style="background-color: rgb(255, 202, 215);" id="2ee58e51-4293-44e9-bb76-ce4342550637">explícita: las palabras y gestos</gistnote> expresados y percibidos. El arco a rayas representa la comunicación <gistnote class="gistnote-highlight" highlightid="ce842908-639c-454c-b3a3-cd6226ce19cb" colornum="1" style="background-color: rgb(255, 202, 215);" id="ce842908-639c-454c-b3a3-cd6226ce19cb">implícita: la cultura compartida y experiencia que forma el contexto</gistnote> para la comunicación explícita. En la interacción humana, mucho de la comunicación real se realiza por referencias a un contexto compartido, y el lenguaje humano está construido sobre estas alusiones. Con las computadoras pasa lo mismo.
</p><p>No es coincidencia que una computadora pueda ser vista como uno de los participantes de la figura 1. En este caso, el "cuerpo" provee una pantalla visual de información, y percepción de la entrada del usuario humano. La "mente" de una computadora incluye los elementos de memoria y procesamiento internos y sus contenidos. La figura 1 muestra que hay varios ítems involucrados en el diseño de un lenguaje de computadora:
</p><p>
</p><p><b><gistnote class="gistnote-highlight" highlightid="98e7cf53-6fb6-4a4a-b6a1-51d738c9124b" colornum="1" style="background-color: rgb(255, 202, 215);" id="98e7cf53-6fb6-4a4a-b6a1-51d738c9124b">Alcance:</gistnote></b> <i>El <gistnote class="gistnote-highlight" highlightid="b34f0171-cf35-49ec-8646-1cd923abc04d" colornum="1" style="background-color: rgb(255, 202, 215);" id="b34f0171-cf35-49ec-8646-1cd923abc04d">diseño</gistnote> de un lenguaje para usar computadoras debe tratar con <gistnote class="gistnote-highlight" highlightid="1b1122a3-c05a-4fef-89fd-a81c0ff0c421" colornum="1" style="background-color: rgb(255, 202, 215);" id="1b1122a3-c05a-4fef-89fd-a81c0ff0c421">modelos internos, medios externos, y con la interacción entre ellos</gistnote> tanto en el <gistnote class="gistnote-highlight" highlightid="09eed103-c37e-4b23-872a-70e10817335d" colornum="1" style="background-color: rgb(255, 202, 215);" id="09eed103-c37e-4b23-872a-70e10817335d">humano</gistnote> como en la <gistnote class="gistnote-highlight" highlightid="1500c12d-0651-40cd-95b1-2f042655cabe" colornum="1" style="background-color: rgb(255, 202, 215);" id="1500c12d-0651-40cd-95b1-2f042655cabe">computadora.</gistnote></i>
</p><p>
</p><p>Este hecho es responsable de la dificultad de enseñar <gistnote class="gistnote-highlight" highlightid="6a748cdd-30d6-4964-843b-74a69ed623e6" colornum="1" style="background-color: rgb(255, 202, 215);" id="6a748cdd-30d6-4964-843b-74a69ed623e6">Smalltalk</gistnote> a gente que ve a los lenguajes de computadora en un sentido más restringido. Smalltalk no es simplemente una mejor manera de <gistnote class="gistnote-highlight" highlightid="ae6f7166-b2a2-42e4-8ff2-15cfc82cccca" colornum="1" style="background-color: rgb(255, 202, 215);" id="ae6f7166-b2a2-42e4-8ff2-15cfc82cccca">organizar procedimientos</gistnote> o un técnica distinta para <gistnote class="gistnote-highlight" highlightid="34b0b36f-1f6f-4e5e-a4f8-28687868e55b" colornum="1" style="background-color: rgb(255, 202, 215);" id="34b0b36f-1f6f-4e5e-a4f8-28687868e55b">administración de memoria</gistnote>. No es sólo un <gistnote class="gistnote-highlight" highlightid="74560abb-7453-4a7b-99c5-613ec455c46c" colornum="1" style="background-color: rgb(255, 202, 215);" id="74560abb-7453-4a7b-99c5-613ec455c46c">jerarquía extensible de tipos de datos</gistnote>, o una <gistnote class="gistnote-highlight" highlightid="7bb4e75b-3b55-40fd-9420-face3eff4c0c" colornum="1" style="background-color: rgb(255, 202, 215);" id="7bb4e75b-3b55-40fd-9420-face3eff4c0c">interfaz gráfica</gistnote> al usuario. Es todas estas cosas, y cualquier otra que sea necesaria para soportar las interacciones ilustradas en la figura 1.
</p><p>
</p><h3><gistnote class="gistnote-highlight" highlightid="4f2685f3-56e2-490e-990d-e4180b436792" colornum="3" style="background-color: rgb(255, 251, 120);" id="4f2685f3-56e2-490e-990d-e4180b436792">Objetos que se Comunican</gistnote></h3>
<p>La mente observa un vasto universo de experiencia, tanto inmediata como recordada. Uno puede tener un sentido de unidad con el universo simplemente al dejar que esta experiencia sea, simplemente como es. Sin embargo, si uno quiere participar, literalmente tomar parte en el universo, uno debe diferenciar. Al hacerlo uno identifica un objeto en el universo, y simultáneamente todo el resto se convierte en no-ese-objeto. La diferenciación por sí misma es un comienzo, pero el proceso de distinguir no es sencillo. Cada vez que quieras hablar sobre "esa silla que está ahí" tienes que repetir el proceso entero de diferenciarla. Acá es donde el acto de <gistnote class="gistnote-highlight" highlightid="8f8c5937-8510-442d-8995-1f5a380e6676" colornum="3" style="background-color: rgb(255, 251, 120);" id="8f8c5937-8510-442d-8995-1f5a380e6676">referenciar</gistnote> entra: podemos <gistnote class="gistnote-highlight" highlightid="20a8341f-dfc4-4c69-bc73-fc7b9b98ccd3" colornum="3" style="background-color: rgb(255, 251, 120);" id="20a8341f-dfc4-4c69-bc73-fc7b9b98ccd3">asociar un identificador único al objeto,</gistnote> y, desde ese momento, sólo el mencionar al identificador es necesario para referenciar al objeto original.
</p><p>Hemos dicho que un sistema de computación debe proveer modelos que sean compatibles con los de la mente. Por lo tanto:
</p><p>
</p><p><b><gistnote class="gistnote-highlight" highlightid="00fd1553-ac2e-4b56-b12a-ba89bdba67a2" colornum="3" style="background-color: rgb(255, 251, 120);" id="00fd1553-ac2e-4b56-b12a-ba89bdba67a2">Objetos</gistnote>:</b> <i>Un lenguaje de computación debe soportar el concepto de "objeto" y proveer una <gistnote class="gistnote-highlight" highlightid="55190a0e-c9bb-40a9-8f5b-9f4f3d6c3fb4" colornum="3" style="background-color: rgb(255, 251, 120);" id="55190a0e-c9bb-40a9-8f5b-9f4f3d6c3fb4">manera uniforme de referirse a los objetos</gistnote> de universo.</i>
</p><p>
</p><p>El administrador de almacenamiento de Smalltalk provee un modelo orientado a objetos de la memoria de todo el sistema. La referenciación uniforme se obtiene simplemente asociando un entero que no se repite a cada objeto del sistema. Esta uniformidad es importante porque significa que las variables en el sistema pueden indicar valores ampliamente variados y aún así ser implementadas como simples <gistnote class="gistnote-highlight" highlightid="0b82aa65-dcd0-452f-abea-5c505cf62e53" colornum="3" style="background-color: rgb(255, 251, 120);" id="0b82aa65-dcd0-452f-abea-5c505cf62e53">posiciones de memoria</gistnote>. Se crean objetos al evaluarse las expresiones, y pueden ser pasados de un lado a otro gracias a la referenciación uniforme, por eso no es necesaria una manera de almacenamiento en los procedimientos que los manipulan. Cuando todas las referencias a un objeto han desaparecido del sistema, el propio objeto se esfuma, y su espacio de almacenamiento es recuperado. Este comportamiento es esencial para soportar completamente la metáfora de objetos.
</p><p>
</p><p><b><gistnote class="gistnote-highlight" highlightid="75c56f93-4440-4d5b-b771-b2e363eaf882" colornum="3" style="background-color: rgb(255, 251, 120);" id="75c56f93-4440-4d5b-b771-b2e363eaf882">Administración del Almacenamiento</gistnote>: </b> <i>Para ser auténticamente "<gistnote class="gistnote-highlight" highlightid="193cc549-a228-41db-aba1-314a4a390346" colornum="3" style="background-color: rgb(255, 251, 120);" id="193cc549-a228-41db-aba1-314a4a390346">Orientado a Objetos</gistnote>" un <gistnote class="gistnote-highlight" highlightid="5bbbde35-58b7-407b-9685-5236e4f21384" colornum="3" style="background-color: rgb(255, 251, 120);" id="5bbbde35-58b7-407b-9685-5236e4f21384">sistema debe proveer administración automática</gistnote> del almacenamiento.</i>
</p><p>
</p><p>Una manera de ver si un lenguaje está funcionando bien es <gistnote class="gistnote-highlight" highlightid="143dfef4-398d-47d8-be1c-358996010130" colornum="3" style="background-color: rgb(255, 251, 120);" id="143dfef4-398d-47d8-be1c-358996010130">ver si los programas parecen estar haciendo lo que hacen</gistnote>. Si están salpicados con <gistnote class="gistnote-highlight" highlightid="0a9c2059-6540-4339-8519-157016d98c43" colornum="3" style="background-color: rgb(255, 251, 120);" id="0a9c2059-6540-4339-8519-157016d98c43">instrucciones</gistnote> de administración del almacenamiento, entonces su modelo interno <gistnote class="gistnote-highlight" highlightid="d4635ae0-afa2-4ab1-b8f4-51bc10111559" colornum="3" style="background-color: rgb(255, 251, 120);" id="d4635ae0-afa2-4ab1-b8f4-51bc10111559">no está bien adaptado al del los humanos.</gistnote> ¿Podrías imaginar tener que preparar a alguien para cada cosa que le digas, o tener que informarle cuando terminaste con determinado tópico y ya puede ser olvidado?
</p><p>Cada objeto en nuestro universo tiene su propia vida. Similarmente, el cerebro provee procesamiento independiente juntamente con el almacenamiento de cada objeto mental. Esto sugiere un <gistnote class="gistnote-highlight" highlightid="bf622bc2-41b8-4025-9b35-5c05bd86466f" colornum="3" style="background-color: rgb(255, 251, 120);" id="bf622bc2-41b8-4025-9b35-5c05bd86466f">tercer principio</gistnote> para el diseño orientado a objetos:
</p><p>
</p><p><b><gistnote class="gistnote-highlight" highlightid="3ce2d925-5c6f-48a6-9bcc-b870e4738feb" colornum="3" style="background-color: rgb(255, 251, 120);" id="3ce2d925-5c6f-48a6-9bcc-b870e4738feb">Mensajes</gistnote>: </b> <i>La <gistnote class="gistnote-highlight" highlightid="4f82b9c7-6b06-439f-844e-60f5c017a1f5" colornum="3" style="background-color: rgb(255, 251, 120);" id="4f82b9c7-6b06-439f-844e-60f5c017a1f5">computación</gistnote> debería ser vista como una <gistnote class="gistnote-highlight" highlightid="9176cc1b-40eb-4628-994f-8f6756ee3f69" colornum="3" style="background-color: rgb(255, 251, 120);" id="9176cc1b-40eb-4628-994f-8f6756ee3f69">capacidad intrínseca de los objetos que pueden ser invocados uniformemente enviándoles mensajes.</gistnote></i>
</p><p>
</p><p>Así como los programas se ensucian  si el almacenamiento de los objetos debe ser tratado explícitamente, el control en el sistema se vuelve complicado si debe ser tratado extrínsicamente. Consideremos el proceso de sumarle 5 a un número. En la mayoría de los sistemas de computación, el compilador averigua que tipo de número es y genera el código para sumarle 5. Esto no está bien para un sistema orientado a objetos porque los tipos exactos de números no pueden ser determinados por el compilador (más sobre esto después). Una solución posible es llamar a una rutina general de suma que examine el tipo de los argumentos para determinar la acción apropiada. Este no es un buen enfoque porque significa que esta rutina crítica debe ser editada por novatos que sólo quieren experimentar con sus propias clases de números. Es también un diseño pobre porque los aspectos internos de los objetos están desparramados por todo el sistema.
</p><p>Smalltalk provee una solución mucho más limpia: Envía el nombre de la operación deseada, juntamente con cualquier parámetro necesario, como un <gistnote class="gistnote-highlight" highlightid="ac6268c7-9cb9-468c-bf34-1e78c284d603" colornum="3" style="background-color: rgb(255, 251, 120);" id="ac6268c7-9cb9-468c-bf34-1e78c284d603">mensaje</gistnote> al número, entendiendo que <gistnote class="gistnote-highlight" highlightid="8b432dfd-991a-48a9-8640-b6619ed676ce" colornum="3" style="background-color: rgb(255, 251, 120);" id="8b432dfd-991a-48a9-8640-b6619ed676ce">el receptor es el que mejor sabe cómo realizar la operación deseada</gistnote>. En vez de un procesador pulverizador de bits destripando y saqueando estructuras de datos, tenemos un universo de objetos que se portan bien, que cortésmente se piden unos a otros realizar sus variados deseos. La transmisión de mensajes es el único proceso que se hace afuera de los objetos y así es como debiera ser, ya que los mensajes viajan entre objetos. El <gistnote class="gistnote-highlight" highlightid="83875f7d-1d66-4183-a285-b081fe49c755" colornum="3" style="background-color: rgb(255, 251, 120);" id="83875f7d-1d66-4183-a285-b081fe49c755">principio</gistnote> de buen diseño puede ser <gistnote class="gistnote-highlight" highlightid="106cafc7-4fe1-4395-a8d4-26ffa5ac5338" colornum="3" style="background-color: rgb(255, 251, 120);" id="106cafc7-4fe1-4395-a8d4-26ffa5ac5338">reexpresado</gistnote> para lenguajes:
</p><p>
</p><p><b><gistnote class="gistnote-highlight" highlightid="7fd370af-09d1-43b1-a04b-538203a673bc" colornum="3" style="background-color: rgb(255, 251, 120);" id="7fd370af-09d1-43b1-a04b-538203a673bc">Metáfora Uniforme</gistnote>: </b> <i>Un lenguaje debería ser <gistnote class="gistnote-highlight" highlightid="a3663031-be64-47a6-b754-3f8bb242577a" colornum="3" style="background-color: rgb(255, 251, 120);" id="a3663031-be64-47a6-b754-3f8bb242577a">diseñado alrededor de una metáfora</gistnote> poderosa que pueda ser <gistnote class="gistnote-highlight" highlightid="090285d4-68e7-41ad-a17d-61a14f248f36" colornum="3" style="background-color: rgb(255, 251, 120);" id="090285d4-68e7-41ad-a17d-61a14f248f36">aplicada</gistnote> uniformemente <gistnote class="gistnote-highlight" highlightid="e7aefe19-e46e-4f6c-aefe-2c76dc6be205" colornum="3" style="background-color: rgb(255, 251, 120);" id="e7aefe19-e46e-4f6c-aefe-2c76dc6be205">en todas las áreas</gistnote>.</i>
</p><p>
</p><p>Ejemplos de éxitos en esta área incluyen a LISP, que está construido sobre el modelo de listas enlazadas; APL, que está construido sobre el modelo de arreglos; y Smalltalk, que está construido sobre el modelo de objetos que se comunican. En cada caso, las aplicaciones grandes son vistas en la misma manera en que las unidades fundamentales de las cuales el sistema está construido. Especialmente en Smalltalk, la interacción entre los objetos más primitivos es vista en la misma manera que la interacción de más alto nivel entre la computadora y su usuario. <gistnote class="gistnote-highlight" highlightid="3f770ca0-7811-49bf-8a37-09a5796b96c3" colornum="3" style="background-color: rgb(255, 251, 120);" id="3f770ca0-7811-49bf-8a37-09a5796b96c3">Todo objeto</gistnote> en Smalltalk, hasta un humilde entero, tiene un <gistnote class="gistnote-highlight" highlightid="3687179d-1ad9-4ec5-b88b-7ad1e4d1e29e" colornum="3" style="background-color: rgb(255, 251, 120);" id="3687179d-1ad9-4ec5-b88b-7ad1e4d1e29e">conjunto de mensajes</gistnote>, un protocolo, que define la <gistnote class="gistnote-highlight" highlightid="33162238-472f-4192-931d-3ebfe324674c" colornum="3" style="background-color: rgb(255, 251, 120);" id="33162238-472f-4192-931d-3ebfe324674c">comunicación explícita a la que ese objeto puede responder</gistnote>. Internamente, los objetos pueden tener almacenamiento local y acceso a otra información compartida que comprenden el contexto implícito de toda comunicación. Por ejemplo,  el mensaje + 5 (sume cinco) lleva una suposición implícita de que el sumando es el número que recibe el mensaje.
</p><p>
</p><h3><gistnote class="gistnote-highlight" highlightid="fd8a1105-27c0-41d7-91cc-9bab8b0f5f0b" colornum="5" style="background-color: rgb(180, 255, 235);" id="fd8a1105-27c0-41d7-91cc-9bab8b0f5f0b">Organización</gistnote></h3>
<p>Una metáfora uniforme provee el marco en el cual se pueden construir sistemas complejos. Algunos principios de organización relacionados entre sí contribuyen a la administración exitosa de la complejidad. Para empezar:
</p><center><font size="-1">
<img src="./Smalltalking_ Design Principles Behind Smalltalk_files/fig2.gif"><br>Figura 2: Complejidad de un sistema.
</font></center>
<p>Al incrementarse la cantidad de componentes de un sistema, la probabilidad de interacción no deseada crece rápidamente. Por esto, un lenguaje de computadora debería ser diseñado para minimizar las posibilidades de esa interdependencia.
</p><p>
</p><p><b>Modularidad:</b> <i>Ningún componente en un sistema complejo debería depender de los detalles internos de ningún otro componente.</i>
</p><p>
</p><p>Este principio es ilustrado en la figura 2. Si hay N componentes en un sistema, entonces hay aproximadamente N2 dependencias potenciales entre ellos. Si los sistemas de computación son para alguna vez asistir a las tareas humanas complejas, deben ser diseñados para minimizar esta interdependencia. La metáfora de envío de mensajes provee modularidad al desacoplar la intención del mensaje (incorporado en el nombre) del método usado por el receptor para realizar la intención. La información estructural es similarmente protegida porque todo acceso al estado interno de un objeto es a través de esta misma interfaz de mensajes.
</p><p>La complejidad de un sistema puede muchas veces ser reducida agrupando componentes similares. Este agrupamiento es conseguido a través del tipado de datos en los lenguajes de programación convencionales, y a través de clases en Smalltalk. Una clase describe otros objetos -su estado interno, el protocolo de mensajes que reconocen, y los métodos internos para responder a esos mensajes. Los objetos así descriptos se llaman instancias de la clase. Incluso las propias clases entran en este esquema; simplemente son instancias de la clase Class, que describe el protocolo y la implementación apropiados para la descripción de los objetos:
</p><p>
</p><p><b>Clasificación:</b> <i>Un lenguaje debe proveer un medio para clasificar objetos similares, y para agregar nuevas clases de objetos en pie de igualdad con las clases centrales del sistema.</i>
</p><p>
</p><p>La clasificación es la objetivación de la idadidad. En otras palabras, cuando un humano ve una silla, la experiencia es interpretada tanto literalmente como "es mismísima silla" y en forma abstracta cono "esa cosa similar a una silla". Esta abstracción resulta de la maravillosa capacidad de la mente de combinar experiencias "similares", y esta abstracción se manifiesta como otro objeto en la mente, la silla Platónica o silla<i>cidad</i>.
</p><p>Las clases son el principal mecanismo de extensión en Smalltalk. Por ejemplo, un sistema de música sería creado agregando nuevas clases que describen la representación y el protocolo de interacción de Note (nota), Melody (melodía), Score (partitura), Timbre, Player  (ejecutante), etc. La cláusula "en pie de igualdad" del principio recién enunciado es importante porque asegura que el sistema va a ser usado como fue diseñado. En otras palabras, una melodía puede ser representada como una colección ad hoc de Integers (números enteros) que representan altura, duración y otros parámetros, pero si el lenguaje permite manejar notas tan fácilmente como enteros, entonces el usuario va a describir naturalmente una melodía como una colección de notas. En cada etapa del diseño, un humano va a elegir en forma natural la representación más efectiva si el sistema la provee. El principio de modularidad tiene una implicación interesante para los componentes procedurales de un sistema.
</p><p>
</p><p><b>Polimorfismo:</b> <i>Un programa sólo debería especificar el comportamiento esperado de los objetos, no su representación.</i>
</p><p>
</p><p>Un afirmación inferida de este principio es que un programa nunca debería declarar que cierto objeto es un SmallInteger (entero chico) o un LargeInteger (entero grande), sino sólo que responde al protocolo de los enteros. Esta descripción genérica es crucial para los modelos del mundo real.
</p><p>Considera una simulación de tránsito automotor. Muchos procedimientos en este sistema se referirán a los diversos vehículos involucrados. Supón que uno quisiera agregar, por ejemplo, un camión barrecalles. Una cantidad substancial de computación (por recompilación) y posibles errores estarían involucrados para hacer esta simple extensión si el código dependiera de los objetos que manipula. La interfaz de mensajes establece un marco ideal para esta extensión. Dado que los camiones barrecalles soportan el mismo protocolo que los demás vehículos, no hacen falta cambios para incluirlos en la simulación.
</p><p>
</p><p><b>Factorización:</b> <i>Cada componente independiente de un sistema sólo debería aparecer en un sólo lugar.</i>
</p><p>
</p><p>Hay muchas razones para este principio. Primero que todo, ahorra tiempo, esfuerzo y espacio si los agregados al sistema sólo necesitan hacerse en un lugar. Segundo, los usuarios pueden encontrar más fácilmente un componente que satisfaga una dada necesidad. Tercero, en la ausencia de una factorización apropiada, aparecen problemas para sincronizar cambios y para asegurar que todos los componentes interdependientes son consistentes. Puedes ver que una falla en la factorización implica una violación a la modularidad.
</p><p>Smalltalk promueve diseños bien factorizados a través de la herencia. Todas las clases heredan comportamiento de su superclase. Esta herencia se desarrolla a través de clases cada vez más generales, terminando finalmente con la clase Object (objeto) que describe el comportamiento mínimo de todos los objetos del sistema. En nuestra simulación del tránsito, StreetSweeper (camión barrecalles), y todas las otras clases de vehículos, serían descriptas como subclases de una clase Vehicle (vehículo) general; así heredando comportamiento mínimo apropiado y evitando la repetición de los mismos conceptos en muchos lugares distintos. La herencia ilustra una forma más pragmática de factorización:
</p><p>
</p><p><b>Reaprovechamiento: </b> <i>Cuando un sistema está bien factorizado, un gran reaprovechamiento  está disponible tanto para los usuarios como para los implementadores.</i>
</p><p>
</p><p>Toma el ejemplo de ordenar una secuencia de objetos. En Smalltalk, el usuario definiría un método sort (ordenar) en la clase OrderedCollection (secuencia). Cuando esto ya ha sido hecho, todas las formas de secuencias en el sistema van a adquirir esta nueva capacidad a través de la herencia. Por otra parte, vale notar que el mismo método sirve tanto para alfabetizar texto como para ordenar números, ya que el protocolo de comparación es reconocido tanto por las clases de texto como por las de números.
</p><p>Los beneficios de la estructuración para los implementadores son obvios. Para empezar, habrá menos primitivas para implementar. Por ejemplo, todos los gráficos en Smalltalk se hacen con una sola operación primitiva. Con sólo una tarea para hacer, un implementador puede aplicar su máxima atención a cada instrucción, sabiendo que cada pequeña mejora en eficiencia será amplificada en todo el sistema. Es natural preguntar qué conjunto de operaciones primitivas serán suficientes para soportar un sistema de computación entero. La respuesta a esta pregunta se llama especificación de una máquina virtual.
</p><p>
</p><p><b>Máquina Virtual: </b> <i>Una especificación de máquina virtual establece un marco para la aplicación de tecnología.</i>
</p><p>
</p><p>La máquina virtual de Smalltalk establece un modelo orientado a objetos para el almacenamiento, un modelo orientado a mensajes para el procesamiento, y un modelo de bitmap (mapa de bits) para el despliegue visual de información. A través del uso de microcódigo, y eventualmente hardware, la performance del sistema puede ser mejorada dramáticamente sin ningún compromiso de las otras virtudes del sistema.
</p><p>
</p><h3>Interfaz al Usuario</h3>
<p>Una interfaz al usuario es simplemente un lenguaje en el que la mayor parte de la comunicación es visual. Dado que la presentación visual se asimila mucho a la cultura humana establecida, la estética juega un rol muy importante en esta área. Como toda la capacidad de un sistema de computación finalmente es entregada a través de la interfaz al usuario, la flexibilidad es esencial también acá. Una condición habilitante para la flexibilidad adecuada de una interfaz al usuario puede ser enunciada como un principio orientado a objetos:
</p><p>
</p><p><b>Principio Reactivo: </b> <i>Cada componente accesible al usuario debería ser capaz de presentarse de una manera entendible para ser observado y manipulado.</i>
</p><p>
</p><p>Este criterio está bien soportado por el modelo de objetos que se comunican. Por definición, cada objeto provee un protocolo de mensajes apropiado para la interacción. Este protocolo es esencialmente un microlenguaje particular para sólo ese tipo de objeto. Al nivel de la interfaz al usuario, el lenguaje apropiado para cada objeto en la pantalla es presentado visualmente (como texto, menúes, imágenes) y percibido a través de la actividad del teclado y el uso de un dispositivo apuntador.
</p><p>Debería notarse que los sistemas operativos parecen violar este principio. Aquí el programador debe alejarse de un marco de descripción que de otra manera es consistente, dejar cualquier contexto ya construido, y enfrentarse con un entorno completamente distinto y usualmente muy primitivo. Esto no tiene por qué ser así:
</p><p>
</p><p><b>Sistema Operativo:</b> <i>Un sistema operativo es una colección de cosas que no encajan dentro de un lenguaje. No debería existir.</i>
</p><p>
</p><p>Aquí hay algunos ejemplos de componentes de sistemas operativos convencionales que han sido incorporados naturalmente al lenguaje Smalltalk:
</p><p>
</p><p>· Administración del Almacenamiento - Enteramente automático. Los objetos son creados por un mensaje a su clase y destruidos cuando no nadie los referencie. La expansión del espacio de direccionamiento mediante la memoria virtual es igualmente transparente.
</p><p>· Sistema de Archivos - Está incorporado al esquema usual a través de objetos como Files (archivos) y Directories (directorios) con protocolos de mensajes que soportan el acceso a archivos.
</p><p>· Manejo de la Pantalla - La pantalla es simplemente una instancia de la clase Form (figura), que es continuamente visible, y los mensajes de manipulación gráfica definidos en esa clase se usan para cambiar la imagen visible.
</p><p>· Entrada del Teclado - Los dispositivos de entrada del usuario se modelan similarmente como objetos con mensajes apropiados para determinar su estado o leer la su historia como una secuencia de eventos.
</p><p>· Acceso a Subsistemas - Los subsistemas se incorporan naturalmente como objetos independientes dentro de Smalltalk: aquí pueden usar el amplio universo de descripción existente, y aquellos que involucran interacción con el usuario pueden participar como componentes de la interfaz al usuario.
</p><p>· Debugger (herramienta de depuración) - El estado del procesador de Smalltalk es accesible como una instancia de la clase Process (proceso) que es dueña de una cadena de stacks. El debugger es sólo un subsistema de Smalltalk que tiene acceso a manipular el estado de un proceso suspendido. Es de notar que casi el único error de tiempo de ejecución que puede ocurrir en Smalltalk es que un mensaje no sea entendido por su receptor.
</p><p>Smalltalk no tiene "sistema operativo" como tal. Las operaciones primitivas necesarias, como leer una página del disco, son incorporadas como métodos primitivos en respuesta a mensajes Smalltalk normales.
</p><p>
</p><h3>Trabajo futuro</h3>
<p>Como es de esperar, hay trabajo por hacer en Smalltalk. La parte mas fácil de describir es la aplicación continuada de los principios de este artículo. Por ejemplo, el sistema Smalltalk-80 es deficiente en su factorización porque sólo soporta herencia jerárquica. Futuros sistemas Smalltalk generalizarán este modelo a herencia arbitraria (múltiple). Además, el protocolo de mensajes no se ha formalizado. La organización provee protocolos, pero actualmente es sólo una cuestión de estilo que los protocolos sean consistentes de una clase a otra. Esto puede ser remediado fácilmente proveyendo objetos protocolo apropiados que puedan ser compartidos consistentemente. Esto posibilitará el tipado formal de variables por protocolo, sin perder las ventajas del polimorfismo.
</p><p>El otro trabajo que queda es menos fácil de articular. Hay claramente otros aspectos del pensamiento humano que no han sido tratados en este artículo. Deben ser identificados como metáforas que puedan complementar los modelos existentes del lenguaje.
</p><p>A veces el avance en los sistemas de computación parece deprimentemente lento. Nos olvidamos que las máquinas de vapor eran "high-tech" para nuestros abuelos. Soy optimista sobre la situación. Los sistemas de computación están, realmente, simplificándose y, como resultado, más usables. Quisiera cerrar con un principio general que gobierna este proceso:
</p><p>
</p><p><b>Selección Natural: </b> <i>Los lenguajes y sistemas que son de buen diseño persistirán, sólo para ser reemplazados por otros mejores. </i>
</p><p>
</p><p>Así como el reloj avanza, mejor y mejor soporte de computación para el espíritu creativo está evolucionando. La ayuda está en camino.
</p><p>
</p><hr>
<p>Traducido por <a href="mailto:jmvuletich@sinectis.com.ar">Juan Manuel Vuletich [jmvuletich@sinectis.com.ar]</a>
</p><p>Smalltalking - <a href="https://www.smalltalking.net/">[http://www.smalltalking.net]</a>


</p><div id="weava-permanent-marker" date="1599696009420"></div><div id="weava-ui-wrapper"><div class="weava-drop-area-wrapper"><div class="weava-drop-area"></div>
<div class="weava-drop-area-text">Drop here!</div>
</div><iframe id="weava-sidebar-iframe" scrolling="no" frameborder="0" src="./Smalltalking_ Design Principles Behind Smalltalk_files/sidebar-index.html" style="right: 0px !important;"></iframe></div></body></html>